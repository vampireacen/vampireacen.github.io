<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:index</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<div id="title" align=center>
<font face="黑体" size=7>

<strong>计算机视觉知识汇总</strong>
</font>
</div>

<h1 id="transformer-">Transformer主干网络</h1>
<h2 id="transformer">Transformer</h2>
<div align=center>

<img src="./img/transformer.jpg" alt="transformer">

</div>

<h3 id="input-embedding">input Embedding</h3>
<div id="im">
<p>

<strong>input Embedding</strong> 就是 <strong>nlp</strong> 中的 <strong>word embedding</strong> 词编码 (只涉及cv知识，其他方向不做详述)

</p>
</div>

<h3 id="positional-encoding">Positional Encoding</h3>
<div id="pe">

经过<strong>word embedding</strong> 获得了词与词之间的关系表述，但是<strong>word embedding</strong>是对所有词同时编码无法获得其位置关系，由于<strong>Transforme</strong>r中是并行的处理所有句子，因此需要加入词在句子中的位置信息，所以进行<strong>Positional Embedding</strong>。
论文中给出了两种位置编码形式：
* 根据所给公式进行绝对位置编码：

<div align=center>

<img src="./img/position_embedding.png" alt="transformer">

</div>

<ul>
<li>使用可训练位置编码，让网络自己学习其位置编码
由于这两种编码在实验中的效果相差很小，所以作者为了减少参数量选择了根据公式进行绝对位置编码。</li>
</ul>
<p></div></p>
<h3 id="encoder">Encoder</h3>
<div id="encoder">
#### Multi-Head self-Attention

<div align=center> 

<strong>$Attention(Q,K,V) = softmax(\frac{QK^T}{\sqrt{d_k}})V$</strong>

</div>

<p><img src="./img/sa2.png" alt="transformer">
<img src="./img/sa3.png" alt="transformer">
经过编码后的输入$a1$,$a2$(为了方便描述取两个输入)与$Q,K,V$(可训练)权重矩阵相乘生成对应的$q_1,k_1,v_1$ 与 $q_2,k_2,v_2$,再每一个$q_i$与每一个$k_i$做<strong>点积 (dot product)</strong>，由于transformer全都可以并行化操作所以这里其实就是$QK^T$，然后再比上$\sqrt{d_k}$($d_k$是K的维度)，再经过$softmax$后与$V$进行矩阵乘。</p>
<p>这里有几个问题：</p>
<ul>
<li>$Q1$：$Q,K,V$分别是什么意思？</li>
<li>$A1$：首先$Q,K,V$分别是<strong>Query，Key，Value</strong>的缩写，<strong>Query，Key，Value</strong>的概念取自于信息检索系统，举个简单的搜索的例子来说。当你在某电商平台搜索某件商品（年轻女士冬季穿的红色薄款羽绒服）时，你在搜索引擎上输入的内容便是<strong>Query</strong>，然后搜索引擎根据<strong>Query</strong>为你匹配<strong>Key</strong>（例如商品的种类，颜色，描述等），然后根据<strong>Query</strong>和<strong>Key</strong>的相似度得到匹配的内容（Value)。<a href="https://zhuanlan.zhihu.com/p/48508221">来源 https://zhuanlan.zhihu.com/p/48508221</a></li>
<li>$Q2$: <strong>Transformer</strong>中为什么使用不同的$K$ 和 $V$， 为什么不能使用同一个值？或者为什么是$Q,K,V$而不是$K$ 和 $V$ 或者$Q$ 和 $V$？</li>
<li>$A2$: $Q$ 如果自己跟自己($Q$)相乘的话，那么根据向量点积知识知道，俩个向量越相似，内积越大，当一个向量与自己做内积，再与其他不同词的向量做内积后(行成一个打分向量)，该向量经过<strong>softmax</strong>后，就会变为一个有一个位置的值特殊的大(自己与自己相乘)，其他位置的值非常非常小的状况出现，比如[0.98,0.01,0.05,0.05]那么,这样的得分再与$V$矩阵相乘后得出的加权向量就是一个基本上跟自己本身差不多的矩阵，那就失去了<strong>self attention</strong>的意义了。</li>
<li>$Q3$：为什么$QK^T$要先除以$\sqrt{d_k}$再<strong>softmax</strong>？</li>
<li>$A3$:对于一个输入向量  ，<strong>softmax</strong>函数将其映射/归一化到一个分布。在这个过程中，<strong>softmax</strong>先用一个自然底数$\exp$将输入中的元素间差距先“拉大”，再除以$\sum e^x_i$后归一化为一个分布。假设某个输入$x$中最大的的元素下标是$k$，如果输入的数量级变大（每个元素都很大），那么会非常接近1。数量级对<strong>softmax</strong>得到的分布影响非常大。在数量级较大时，<strong>softmax</strong>将几乎全部的概率分布都分配给了最大值对应的标签。那么就将产生一个接近<strong>one-hot</strong>的向量,所以反向传播时梯度就消失为0。</li>
<li>$Q4$: 为什么$QK^T$是除以$\sqrt{d_k}$而不是随便除以一个数？</li>
<li>$A4$: $q$ 和 $k$ 的各个分量是互相独立的随机变量，均值是0，方差是1，那么点积 $q·k$的均值是0，方差是$\sqrt{d_k}$，所以$\frac{QK^T - 0}{\sqrt{d_k}}$拉回到均值为0， 方差为1的标准正态分布，防止了数量级大使得梯度消失的情况。</li>
</ul>
<div align=center> 

<strong>$MultiHead(Q,K,V) = Concat(head_1,head_2,...,head_h)W^O$</strong>
<strong>$where head_i = Attention(QW_i^Q,KW_i^K,VW_i^V)$</strong>

</div>



<p><img src="./img/self_attention.png" alt="transformer"></p>
<p><strong>self attention</strong>中的输入分别与$W^Q,W^K,W^V$相乘产生$q_i,k_i,v_i(Q,K,V)$, <strong>multi-head self attention</strong> 中每一个head都是一个<strong>self attention</strong>，每一个head都有$W^Q_j,W^K_j,W^V_j$生成每一个head中的$q_j,k_j,v_j$，原文(<strong>线性映射</strong>)直接把<strong>self attention</strong>中的$q_i,k_i,v_i$均分给每个head的$q_i^j,k_i^j,v_i^j$,每一个<strong>head</strong>再做<strong>self attention</strong>然后把每个head的结果$Concat$，最后在做一个线性变换，变换到与输入相同的维度。</p>
<p>问题：</p>
<ul>
<li>$Q$: 为什么需要<strong>multi head</strong>呢，只用一个head不行吗？</li>
<li>$A$: 每个<strong>head</strong>空间中注意到的东西可能都不一样，比如<strong>head</strong>注意到的东西<strong>head</strong>没注意到，<strong>head</strong>注意到的事情<strong>head</strong>没注意到，所以把所有<strong>head</strong>的结果$Concat$相当于注意的更加全面。</li>
</ul>
<h4 id="add-norm">Add &amp; Norm</h4>
<p><strong>Add</strong> 指残差结构，把<strong>multi-head self attention</strong>的输入与其输出做一个相加，因为<strong>multi-head</strong>后的结果经过了一个线性变换使得输入输出是相同的维度，所以可以相加。</p>
<p><strong>Norm</strong>指 <strong>Layer Normalization</strong>，通常用于 <strong>RNN</strong> 结构，<strong>Layer Normalization</strong> 会将每一层神经元的输入都转成均值方差都一样的，这样可以加快收敛。
问题：</p>
<ul>
<li>$Q$: 为什么不用 <strong>Batch Normalization</strong> 而是用 <strong>Layer Normalization</strong>？</li>
<li>$A$: <a href="#bn_vs_ln">答案</a></li>
</ul>
<h4 id="feed-forward">Feed Forward</h4>
<p><strong>Feed Forward</strong> 层比较简单，是一个<strong>两层的全连接层</strong>，第一层的激活函数为 <strong>Relu</strong>，第二层不使用激活函数，对应的公式如下:</p>
<div align=center> 

<strong>$Max(0,XW_1+b_1)W_2 + b2$</strong>

</div>

<p>$X_{(n,d)}$经过<strong>multi-head self attention、add &amp; norm 、feed forward</strong>之后输入$O_{(n,d)}$
</div></p>
<h3 id="decoder">Decoder</h3>
<h4 id="masked-multi-head-self-attention">Masked Multi-Head Self Attention</h4>
<p><strong>Decoder</strong>中的第一个<strong>multi-head self attention</strong>为 <strong><em>Masked</em></strong>  <strong>multi-head self attention</strong>，所谓<strong>mask</strong>是一个$n * n$的下三角矩阵如图：<a href="https://zhuanlan.zhihu.com/p/338817680">https://zhuanlan.zhihu.com/p/338817680</a></p>
<div align=center>

<img src="./img/mask_matrix.jpg" alt="Vit">

</div>

<p>由于<strong>Transform</strong>的并行操作，所以当$QK^T$经过一些列操作后需要与$V$进行矩阵乘，即$QK^T$中的每一个向量需要与$V$中的每一个向量做点积，但是由于句子是序列化，即当第$k$个单词应该只能注意到$k$以及$k$之前的单词，所以这个操作与我们所希望的是违背的，所以需要一个<strong>mas</strong>k矩阵与$QK^T$按位相乘，产生Mask $QK^T$,再softmax后与$V$相乘得相应结果。操作如下：</p>
<div align=center>

<img src="./img/QK%5ET.jpg" alt="Vit">
</div>
<div align=center>

<img src="./img/Mask_QK%5ET.jpg" alt="Vit">
</div>

<h4 id="-multi-head-self-attention">第二个Multi-Head Self Attention</h4>
<p><strong>Decoder block</strong> 第二个 <strong>Multi-Head Attention</strong> 变化不大， 主要的区别在于其中 <strong>Self-Attention</strong> 的 $K, V$矩阵不是使用 上一个 <strong>Decoder block</strong> 的输出计算的，而是使用 <strong>Encoder</strong> 的编码信息矩阵 $C$ 计算的。</p>
<p>根据 <strong>Encoder</strong> 的输出 $C$计算得到 $K, V$，根据上一个 <strong>Decoder block</strong> 的输出 $Z$ 计算 $Q$ (如果是第一个 <strong>Decoder block</strong> 则使用输入矩阵 $X$ 进行计算)，后续的计算方法与之前描述的一致。</p>
<p>这样做的好处是在 <strong>Decoder</strong> 的时候，每一位单词都可以利用到 <strong>Encoder</strong> 所有单词的信息 (这些信息无需 <strong>Mask</strong>)。</p>
<h4 id="softmax-">Softmax 预测输出单词</h4>
<p><strong>Decoder block</strong> 最后的部分是利用 <strong>Softmax</strong> 预测下一个单词，在之前的网络层我们可以得到一个最终的输出 $Z$，因为 <strong>Mask</strong> 的存在，使得单词 $0$ 的输出 $Z_0$ 只包含单词 $0$ 的信息，如下：</p>
<div align=center>

<img src="./img/last_Z.jpg" alt="Vit">

</div>

<p><strong>Softmax</strong> 根据输出矩阵的每一行预测下一个单词：</p>
<div align=center>

<img src="./img/softmaxZ.png" alt="Vit">
</div>

<h3 id="transformer-">Transformer 总结</h3>
<ul>
<li><strong>Transformer</strong> 与 <strong>RNN</strong> 不同，可以比较好地并行训练。</li>
<li><strong>Transformer</strong> 本身是不能利用单词的顺序信息的，因此需要在输入中添加位置 <strong>Embedding</strong>，否则 <strong>Transformer</strong> 就是一个词袋模型了。</li>
<li><strong>Transformer</strong> 的重点是 <strong>Self-Attention</strong> 结构，其中用到的 $Q, K, V$ 矩阵通过输出进行线性变换得到。</li>
<li><strong>Transformer</strong> 中 <strong>Multi-Head Attention</strong> 中有多个 <strong>Self-Attention</strong>，可以捕获单词之间多种维度上的相关系数 <strong>attention score</strong>。</li>
</ul>
<h2 id="vision-transformer-vit-">Vision Transformer(ViT)</h2>
<p><img src="./img/vit.png" alt="Vit"></p>
<h2 id="swin-transformer-swint-">Swin Transformer(SwinT)</h2>
<p><img src="./img/swin_VS_VIT.jpg" alt="swin">
<img src="./img/swint.jpg" alt="swin">
<img src="./img/patch_merge.png" alt="swin">
<img src="./img/shifted_window.png" alt="swin">
<img src="./img/shifted_window_2.png" alt="swin">
<img src="./img/shifted_window_3.png" alt="swin">
<img src="./img/shifted_window_4.png" alt="swin"></p>
<h2 id="swin"><img src="./img/shifted_window_5.png" alt="swin"></h2>
<div id="cnn"></div>

<h1 id="cnn-">CNN主干网络</h1>
<h2 id="cnn-">CNN基础</h2>
<hr>
<h1 id="-">目标检测主流模型</h1>
<h2 id="two-stage">Two Stage</h2>
<h3 id="rcnn-">RCNN系列</h3>
<h4 id="rcnn">RCNN</h4>
<h4 id="fast-rcnn">Fast RCNN</h4>
<h4 id="faster-rnn">Faster RNN</h4>
<h2 id="one-stage">One Stage</h2>
<h3 id="ssd-">SSD系列</h3>
<h4 id="ssd">SSD</h4>
<h4 id="dssd">DSSD</h4>
<h3 id="yolo-">Yolo系列</h3>
<h4 id="yolov1">Yolov1</h4>
<h4 id="yolov2">Yolov2</h4>
<h4 id="yolov3">Yolov3</h4>
<h4 id="yolov3-spp">Yolov3 spp</h4>
<h4 id="yolov4">Yolov4</h4>
<h4 id="yolov5">Yolov5</h4>
<hr>
<h1 id="rnn-">RNN系列</h1>
<h2 id="rnn">RNN</h2>
<h2 id="lstm">LSTM</h2>
<h2 id="gru">GRU</h2>
<h2 id="bilstm">BiLSTM</h2>
<hr>
<h1 id="-">神经网络知识</h1>
<h2 id="-">梯度消失梯度爆炸</h2>
<h2 id="-">激活函数</h2>
<h2 id="normalization">Normalization</h2>
<h3 id="batch-normalization">Batch Normalization</h3>
<h3 id="layer-normalization">Layer Normalization</h3>
<div id="bn_vs_ln"></div>

<h3 id="instance-normalization">Instance Normalization</h3>
<h3 id="group-normalization">Group Normalization</h3>
<h2 id="-">正则</h2>
<h2 id="-">损失函数</h2>
<h2 id="-">优化器</h2>
<hr>
<h1 id="-">机器学习</h1>
<hr>
<h1 id="-">图像处理知识</h1>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>